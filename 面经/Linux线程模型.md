Linux 线程模型

### 基础概念

线程是操作系统能够调度和执行的基本单位，在 Linux 中被称之为轻量级进程。从定义中可以看出，线程他是操作系统的基础概念，在不同的操作系统中的实现是不同的.

对于 Linux 操作系统而言，它对 Thread 的实现方式比较特殊。在 Linux 内核中，其实是没有线程的概念，它把所有的线程当作标准的进程来实现，也就是说 Linux 内核，并没有为线程提供任何特殊的调度语义，也没有为线程实现特定的数据结构。取而代之的是，线程只是一个与其他进程共享某些资源的进程。每一个线程拥有一个唯一的 task_struct 结构，Linux 内核它仅仅把线程当作一个正常的进程，或者说是轻量级进程 LWP(Lightweight processes)。

对于其他操作系统而言，比如 Windows，线程相对于进程，只是一个提供了更加轻量，快速执行单元的概念。对于 Linux 而言，线程只是进程间共享资源的一种方式，非常轻量。举个简单例子，假设有一个进程包含了 N 个线程。这个进程描述符指明共享资源，包括内存空间和打开的文件，然后线程描述他们独享的资源。相反的是在 Linux 中，只有 N 个进程，因此有 N 个 task_struct 数据结构，只是这些数据结构的某些资源项是共享的。

总结一下：Linux 线程是进程资源共享的一种方式，而其它操作系统，线程则是一种实现轻量，快速执行单元的抽象概念或者实体。

### 资源共享

Linux 线程与进程的区别，主要体现在资源共享，调度，性能几个方面，首先看一下资源共享方面。上面也提到，线程其实是共享了某一个进程的资源，这些资源包括：

        1. 内存地址空间
        2. 进程基础信息
        3. 大部分数据
        4. 打开的文件
        5. 信号处理
        6. 当前工作目录
        7. 用户和用户组属性
        ...

        哪些是线程独有的呢？

        1. 线程ID
        2. 一系列的寄存器
        3. 栈的局部变量
        4. 错误码 errno
        5. 信号掩码
        6. 优先级
        ...

这里说一个黑科技，线程拥有独立的调用栈，除了栈之外共享了其他所有的段 Segment。但是由于线程间共享了内存，也就是说一个线程，理论上是可以访问到其他线程的调用栈的，可以用一个指针变量，去访问其他线程的局部栈帧，以访问其他线程的局部变量。

### 调度

说到调度，就得提到进程的上下文切换.上下文切换也被称作进程调度或者任务切换，简单来说是把 CPU 从一个进程或者线程切换到另一个执行。概括来说，线程的上下文切换，要比进程更加快速，因为本质上，线程很多资源都是共享进程的，所以切换时，需要保存和切换的项目就很少。

线程上下文切换时，虚拟地址空间是不变的，但进程上下文切换时，是需要重新映射虚拟地址空间。进程切换上下文时，进出 OS 内核和寄存器切换，是最大时间支出。更模糊的代价是上下文切换时，会干扰处理器的缓存机制。当上下文切换时，处理器需要重新 cache 一些内存。

还有个更大的区别是，当更改虚拟内存地址空间时，CPU 的 TLB 等也会被刷新，导致接下来的内存访问更加耗时，所以相对线程切换来说，进程的切换耗时会更大。

### 性能

从性能方面，来查看一下线程与进程的对比。由于线程更加轻量，导致线程的创建速度，切换速度都要高于进程。这里就有一个疑问了，从上面提到的各个方面来看，好像线程都要优于进程，那么有没有什么缺点呢？

### 线程缺点

线程同样也有缺点，最大的缺点是线程的不安全性，缺乏保护机制。就是上面提到的黑科技，因为线程间共享数据，一个线程可以重写另外以一个线程的堆栈，导致出现一些异常的情况。除此之外，线程还有以下缺点：

        1. 共享属性：全局变量是在所有线程间共享的，访问时需要同步加锁
        2. 很多库函数是非线程安全的，多线程编程时，需要注意这点
        3. 线程健壮性不强，如果一个线程crash了，整个程序崩溃

### 应用场景

上面提到了线程与进程的对比，也提到了线程的优点与缺点，那么什么情况下适合用线程呢？简单的来说，计算密集型的任务，适合于多线程来处理。因为计算密集型任务，需要消耗很多 CPU，上下文的切换自然也是非常频繁的，而线程切换速度是高于进程的，所以使用线程是更加合适的。实际的编程过程中，根据业务的场景，再结合进程和线程的优缺点对比，来决定适合的编程模型。

### 线程创建

那么在 Linux 中线程是如何创建的呢？上面也提到，在 Linux 中线程死一种资源分享的方式，可以在创建进程的时候，指定默写资源是从其他进程共享的，从而在概念上创建一个线程。在 Linux 中，可以通过 clone 系统调用来创建一个进程，它的函数签名如下：

    #include <sched.h>
    int clone(int (_fn)(void _), void *child_stack, int flags, void *args, ...);
    我们在使用 clone 创建进程的过程中，可以指明相应的参数，来决定共享某些资源，比如：
    clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)

这个 clone 系统调用的行为类似于 fork,不过新创建，不过新创建出来的进程，它的内存地址，文件系统资源，打开的文件描述符和信号处理器，都是共享父进程的。换句话说，这个新创建出来的进程，也被叫做 Linux Thread。从这个例子中，也可以看出 Linux 中，线程其实是进程实现资源共享的一种方式。

### 内核线程

在 Linux 中，还存在一个 Kernel Thread 的概念，也就是内核线程。内核创建一些内核线程来执行一些后台任务。相对于普通的进程，内核线程完整的存在于内核空间，是没有自己的地址空间的，也就是 mm 指针为空，他的操作仅存在与内核态，并且也不会上下文切换到用户态。不过内核线程和普通进程类似的是，是可调度和可抢占的。

### 同步

由于线程间共享了很多资源，所以在多线程的编程环境下，为了保障结果的准确性和一致性，需要对共享资源的访问进行同步。常见的同步方式，也就是加锁，以保障操作共享资源时，不会出错。在 Linux 中，锁的种类大致有四种：

    1. 互斥锁
    2. 读写锁
    3. 条件变量
    4. 自旋锁
    5. 自旋锁
    6. 内存屏障

### Linux task_struct

    进程状态：
        5个互斥状态
            TASK_RUNNING：表示进程要么正在执行，要么正要准备执行（已经就绪），正在等待cpu时间片的调度

            TASK_INTERRUPTIBLE：进程因为等待一些条件而被挂起（阻塞）而所处的状态。这些条件主要包括：硬中断、资源、一些信号……，一旦等待的条件成立，进程就会从该状态（阻塞）迅速转化成为就绪状态TASK_RUNNING

            TASK_UNINTERRUPTIBLE: 意义与TASK_INTERRUPTIBLE类似，除了不能通过接受一个信号来唤醒以外，对于处于TASK_UNINTERRUPIBLE状态的进程，哪怕我们传递一个信号或者有一个外部中断都不能唤醒他们。只有它所等待的资源可用的时候，他才会被唤醒。这个标志很少用，但是并不代表没有任何用处，其实他的作用非常大，特别是对于驱动刺探相关的硬件过程很重要，这个刺探过程不能被一些其他的东西给中断，否则就会让进程进入不可预测的状态

            TASK_STOPPED：进程被停止执行，当进程接收到SIGSTOP、SIGTTIN、SIGTSTP或者SIGTTOU信号之后就会进入该状态

            TASK_TRACED: 表示进程被debugger等进程监视，进程执行被调试程序所停止，当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态

        2个中止状态
            EXIT_ZOMBIE: 进程的执行被终止，但是其父进程还没有使用wait()等系统调用来获知它的终止信息，此时进程成为僵尸进程

            EXIT_DEAD: 进程进入最终状态

    进程标识符(PID)
        pid_t pid;
        pid_t tgid;

    Unix系统通过pid来标识进程，linux把不同的pid与系统中每个进程或轻量级线程关联，而unix程序员希望同一组线程具有共同的pid，遵照这个标准linux引入线程组的概念。一个线程组所有线程与领头线程具有相同的pid，存入tgid字段，getpid()返回当前进程的tgid值而不是pid的值。

    在CONFIG_BASE_SMALL配置为0的情况下，PID的取值范围是0到32767，即系统中的进程数最大为32768个。
