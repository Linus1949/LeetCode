### RPC
    Dubbo总结：
            Apache Dubbo是一款高性能、轻量级的开源Java RPC架构，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册与发现。简单来说Dubbo是一个分布式服务框架，致力于提供高性能和透明的RPC远程服务调用方案，以及SOA服务治理方案。
    
    什么是RPC原理：
            RPC(Remote Produce Call)远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解网络底层技术的服务。比如两个不同的服务A、B部署在两个不同的机器上，那么服务A如果想要调用服务B中的某个方法，使用Http请求当然可以，但可能会比较麻烦。RPC的出现就是为了让你调用远程方法像本地方法一样简单。

            1. 服务消费方(client)调用以本地调用方式调用服务
            2. client stub接收到调用后，负责将方法、参数等组装成能够网络传输的消息体(序列化)
            3. client sub找到服务地址，并将消息发送到服务端
            4. server stub根据解码结果调用本地的服务(反序列化)
            5. 本地服务执行并将结果返回给server stub
            6. server stub将返回结果打包成消息并发送至消费方(序列化)
            8 client stub接收到消息，并进行解码(序列化)
            9. 服务消费方得到最终结果

    Dubbo的意义：
            Dubbo的诞生和SAO分布式框架的流行有着莫大的关系.SOA面向服务的框架(Service Oriented Archicture), 也就是把工程按照业务逻辑拆分成服务层、表现层连个工程。服务层中保函业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：服务提供者(Provider)和服务使用者(Consumer)。

            “如果要开发分布式程序，你也可以直接基于HTTP接口进行通信，但是为什么要Dubbo呢？”

            我觉得主要可以从Dubbo提供的四点特性来说

                1.负载均衡--同一个服务部署在不同的机器时刻调用那一台机器上的服务
                2. 服务调用链路生成--随着系统的发展，服务越来越多，服务之间依赖关系变得错综复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo可以帮我们解决服务之间是如何调用的。
                3. 服务访问压力以及时长统计，资源调度和治理--基于访问压力试试管理集群容量，提高集群利用率。
                4. 服务降级--某个服务挂掉之后调用备用服务。

    Dubbo的架构：
            Provider: 暴露服务的服务提供方
            Consumer：调用远程服务的服务消费方
            Registry: 服务注册与发现的服务中心
            Monitor：统计服务的调用次数和调用时间的监控中心
            Container：服务运行容器、

            调用关系说明：
            1. 服务容器负责启动，加载，运行服务提供者
            2. 服务提供者在启动时，向注册中心注册自己提供的服务
            3. 服务消费者在启动时，向注册中心订阅自己所需的服务
            4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者
            5. 服务消费者，从提供者地址列表中，基于软负载算法，选一台提供者进行调用，如果调用失败，再选另一台调用
            6. 消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

            重要知识点：
            1. 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。
            2. 监控中心负责统计各服务调用次数，调用时间等，统计现在内存汇总后每分钟发送到监控中心服务器，并以报表展示。
            3. 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外。
            4. 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件同通知消费者。
            5. 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。
            6. 注册中心和监控中心都是可选的，消费者可以直连提供者。
            7. 服务提供者无状态，任意一台宕机掉后不影响使用。
            8. 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重新等待连接。
    
    Dubbo各层说明：
            第一层: service层，接口层，给服务提供者和消费者来实现
            第二层: config层，配置层，主要对Dubbo进行各种配置的
            第三层：proxy层，服务接口透明代理，生成服务的客户端stub和服务端skeleton
            第四层：registry层，服务注册层，负责服务的注册与发现
            第五层：cluster层，集群层，封装多个服务提供者的路由以及负载均衡，将多实例组曾一个服务
            第六层：monitor层，监控曾，对rpc接口的调用次数和调用时间进行监控
            第七层：protocol层，远程调用层，封装rpc调用
            第八层：exchange层，信息交换层，封装请求响应模式，同步转异步
            第九层：transport层，网络传输层，抽象mina和netty为统一接口
            第十层：serialize层，数据序列化层，网络传输需要

    Dubbo的负载均衡策略：
            负载均衡是为了优化资源使用，最大化吞吐量，最小化相应时间，避免单个资源的过载

            在集群负载均衡时，Dubbo提供多种均衡策列，默认为random，可自行扩展负载均衡策略

            Random LoadBalance(默认，基于权重的随机负载均衡机制)
                1. 按权重设置随机概率
                2. 在一个截面上碰撞概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均衡，有利于动态调整提供者权重
            
            RoundRobin LoadBalance(不推荐，基于权重的轮询负载机制)
                1. 轮询，按公约后的权重设置轮询比率
                2. 存在慢的提供者累计请求的问题，比如：第二台机器很慢，但没挂，当请求调第二台时就卡在那里，久而久之，所有请求都卡在调用第二台上
            
            LeastActive LoadBalance
                1.  最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。
                2.  使慢的提供者收到更少的请求，因为越慢的提供者的调用前后计数差会越大
            
            ConsistentHash LoadBalance
                1.  一致性hash，相同参数的请求早那个是发到同一个提供者。(如果需要的不是随机负载，而是一类请求都到一个节点，那就使用一致性hash)
                2.  当某一台提供者挂了，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。

    zookeeper宕机与dubbo直连的情况
                一段时间内服务消费方还是能够调用服务提供方的，因为它实际使用的是本地缓存列表进行通讯。
                dubbo的健壮性表现：
                    1. 监控中心宕掉不影响使用，只是丢失部分采样数据
                    2.  数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
                    3.  注册中心对等集群，任意一台宕掉后，将自动切换到另一台
                    4.  注册中心全部宕掉后，服务提供者和消费者仍能通过本地缓存通信
                    5.  服务提供者无状态，任意一台宕掉后，不影响使用
                    6.  服务提供者全部宕掉，服务消费者应用将无法使用，并无限次重连等待提供者恢复