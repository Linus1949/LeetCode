### JVM 的调优

    1.何时进行JVM调优？
        . Heap内存(老年代)持续上涨达到设置的最大内存值
        . Full GC次数频繁
        . GC 停顿时间过长
        . 应用出现OutOfMemory等内存异常
        . 应用中有使用本地缓存且占用大量内存空间
        . 系统吞吐量与性能不高或者下降

    2. JVM调优的基本原则
        JVM调优是一个手段，但不是所有问题都可以通过JVM调优解决，因此在JVM调优时，我们要遵循一些原则：
            . 大多数的Java应用不需要进行JVM调优
            . 大多数导致GC问题的原因时代码设计层面导致的(代码层面)
            . 上线之前，应考虑将机器的JVM参数设置到最优
            . 减少创建对象的数量(代码层面)
            . 减少使用全局变量和大对象(代码层面)
            . 优先框架调优和代码调优，JVM优化是不得已的手段(代码，架构层面)
            . 分析GC情况优化代码比优化JVM参数更好(代码层面)

    3. JVM调优目的
        调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。

            . 延迟：GC低停顿，GC低频率
            . 低内存占用
            . 高吞吐量

            其中，任何一个属性性能的提高，几乎都是以牺牲其他属性性能为代价的，不可兼得。

    4. JVM优化量化目标
        . Heap内存使用率 <= 70%
        . Old Generation内存使用率 <= 70%
        . avg pause <= 1秒
        . Full gc次数0 或avg pause interval >= 24小时

    5. JVM调优步骤
        . 分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点
        . 确定JVM调优量化目标
        . 确定JVM调优参数（根据历史JVM参数来调整）
        . 依次调优内存，延迟，吞吐量等指标
        . 对比观察调优前后差异
        . 不断地分析和调整，直到找到合适的JVM参数配置
        . 找到合适的参数，将这些参数应用到所有服务器，并进行后续跟踪

        以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行之。

    6. JVM参数
        JVM调优最重要的工具就是JVM参数了。先来了解一下JVM参数相关内容。
        -XX 参数被称为不稳定参数，此类参数的设置很容易引起JVM 性能上的差异，使JVM存在极大的不稳定性。如果此类参数设置合理将大大提高JVM的性能及稳定性。
        不稳定参数语法规则包含以下内容。
        布尔类型参数值：

            -XX:+ '+'表示启用该选项
            -XX:- '-'表示关闭该选项

        数字类型参数值：

            -XX:=给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。

        字符串类型参数值：

            -XX:=给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core

### Java 进程占用内存过高，排查解决方法

    A: 可能是代码原因导致的问题
        1. 使用命令: top来查看当前进程的状态

        2. 由上图可以看到PID: 916的java进程占用内存较大，定位线程问题，使用命令: ps p916 -L -o pcpu,pmem,pid,tid,time,tname,cmd
        由此可以看到PID: 916的进程产生了很多线程。接下来使用jstack查看内存的使用的堆栈

        3. 查看内存使用的堆栈：在这里我们挑选了TID=934的线程进行分析，首先需要将934这个id转换成16进制。需要输入如下命令：printf "%x\n" 934

        4. 将PID为916的堆栈信息打印到jstack.log中，使用命令: jstack -l 916 > jstack.log

        5. 查看堆栈信息文件，使用命令: vim jstack.log，再进行搜索TID为之前16进制的信息

        6. 分析
            可以看到这个线程的状态为RUNNABLE，是正在运行状态，另外其它的大部分线程为WAITING。通过查看文件分析，看到大量的Java Thread State，说明它正在等待另一个条件的发生，来把自己唤醒，或者干脆是它调用sleep(N).
            此时线程状态大致分为以下几种:
            java.lang.Thread.State: WAITING(parking)：一直等待那个条件发生过;
            java.lang.Thread.State: TIMED_WAITING(parking/sleeping): 定时的，那个条件不到来，也会定时唤醒自己。

        7. 代码优化
            将文件发送给开发优化线程

    B: 可能是其他原因导致的
        1. 使用命令查看当前java进程列表: ps -ef | grep java | grep -v grep

        由上图所示，可以看到java进程是Tomcat的启动进程.
